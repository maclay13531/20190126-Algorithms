<script>
// linear search
//O(n)

// binary search
// assuming that the inputs are sorted, we can divide and conquer
// O(log(n))

// traversal
//O(n)

// breath vs depth
// breath first search go left to right then make your level down
// all traversal is O(n)

// If you know a solution is not far from the root of the tree:
// BFS

// If the tree is very deep and solutions are rare, 
// BFS (DFS will take long time. )

//If the tree is very wide:
// DFS (BFS will need too much memory)

// If solutions are frequent but located deep in the tree
// DFS

// determining whether a path exists between two nodes
// DFS

// Finding the shortest path
// BFS
</script>